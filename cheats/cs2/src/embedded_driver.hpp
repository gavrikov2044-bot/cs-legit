#pragma once
#include <vector>
#include <string>
#include <fstream>
#include <filesystem>
#include <windows.h>

// Forward decl
extern "C" void CleanupExtractedDriver();

// Driver data (generated by bin2header.py)
// If not present, we will try to load from disk
#if __has_include("embedded_driver_data.hpp")
    #include "embedded_driver_data.hpp"
#else
    // Stub if no embedded driver
    namespace embedded {
        const unsigned char driver_data[] = { 0 };
        const size_t driver_size = 0;
    }
#endif

class DriverExtractor {
public:
    struct Result {
        bool success;
        std::string path;
        std::string error;
    };

    static Result Extract() {
        // 1. Check if driver exists on disk
        if (std::filesystem::exists("iqvw64e.sys")) {
            return { true, "iqvw64e.sys", "" };
        }

        // 2. Check embedded data
        if (embedded::driver_size == 0) {
            return { false, "", "No embedded driver and iqvw64e.sys not found" };
        }

        // 3. Extract to temp
        char tempPath[MAX_PATH];
        GetTempPathA(MAX_PATH, tempPath);
        std::string targetPath = std::string(tempPath) + "iqvw64e.sys";

        std::ofstream file(targetPath, std::ios::binary);
        if (!file) {
            return { false, "", "Failed to create temp file" };
        }

        // Simple XOR decryption if needed (currently raw)
        file.write(reinterpret_cast<const char*>(embedded::driver_data), embedded::driver_size);
        file.close();

        return { true, targetPath, "" };
    }
};

// Global cleanup function
void CleanupExtractedDriver() {
    char tempPath[MAX_PATH];
    GetTempPathA(MAX_PATH, tempPath);
    std::string targetPath = std::string(tempPath) + "iqvw64e.sys";
    
    // Try to delete (might fail if loaded)
    DeleteFileA(targetPath.c_str());
}

